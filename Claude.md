Senior Unity Developer
Тестовое задание / Multicast Games
Задача
Создать прототип мобильной игры-головоломки, в которой игрок должен составлять слова из кластеров букв, являющихся последовательностью букв в том порядке, в котором они находятся в заданных словах.
Прототип должен включать следующие элементы:
1. Главное меню:  	
Кнопка "Play", которая запускает последний не пройденный уровень. Если пройдены все уровни то снова запускается первый;
Счетчик, который отображает количество пройденных уровней.
2. Экран игры:
Игровое поле, на котором столбцом расположены четыре незаполненных слова (пустые ячейки под буквы) длиной 6 букв каждое.
В нижней части экрана находится прокручиваемая по горизонтали панель с кластерами букв (по 2-4 буквы в каждом), из которых игроку предстоит составлять загаданные в уровне слова, выкладывая их на игровое поле. Необязательно кластер должен являться слогом слова. Примеры кластеров: (КЛ) (АС) (ТЕР).
Кластеры букв должны быть объединены рамкой для наглядности. Она остается видимой при выкладывании на поле, чтобы игрок мог убрать или переместить неправильно выставленный кластер.
При выставлении нового кластера на игровое поле должна происходить автоматическая валидация игрового поля на правильность выложенных игроком слов. Условием прохождения уровня считается тот факт, что игрок выложил все кластеры на поле и собрал из них все загаданные слова. Положение слов в столбце на поле значения не имеет.
3. Экран победы:
Отображение всех разгаданных слова столбцом в том же порядке, в каком их разгадал игрок
Кнопка “Main Menu”, которая переводит игрока в Главное меню
Кнопка “Next Level”, которая переводит игрока на следующий уровень
Требования
Версия Unity: 6000.x.x
Технологии. Необходимо самостоятельно выбрать технологии подходящие под поставленную задачу. Разрешено использовать сторонние библиотеки которые ускорят разработку и упростят поддержку игры.
Ассеты. Допускается использовать бесплатные ассеты из Unity Asset Store либо можно встроенные примитивы.
Финальная работа: требуется предоставить ссылку на открытый репозиторий GitHub или любой его игры аналог, apk файл (android) и краткое описание архитектуры проекта.
Хранение конфигурации уровней. Конфигурацию уровней необходимо хранить в json файлах. Структуру .json файла уровня необходимо спроектировать самостоятельно.
Сохранение игрового прогресса.  При перезапуске игры должен сохраняться прогресс игрока.

Будет оцениваться
-	Расширяемость архитектуры, а именно сложность доработки проекта под новые требования. Полный список оцениваемых требований:
Расширяемость системы загрузки уровней. Допустим, потребуется заменить загрузку уровней из json-файла на асинхронную загрузку с сервера;
Расширяемость геймплея. Допустим, потребуется сделать игровой режим со словами длиной 8 букв;
Заменяемость геймплея. Допустим, потребуется заменить геймплей, но при этом оставить остальную логику (систему загрузки уровней, сохранения прогресса, интерфейс);
Какое количество кода (не связанного с поставленной задачей) потребуется переписать для решения данных задач? Примечание: задачи из списка выше реализовывать не нужно.
- 	Обоснованность выбора сторонних библиотек. Упрощают и ускоряют ли библиотеки разработку или вносят избыточную сложность для данного проекта.
-	Структура кода. Баланс простоты и производительности. КОличество аллокаций памяти. Разделение конфигурации игры, игровой логики и логики интерфейса.Уместное соблюдение принципов SOLID и KISS
-	Аккуратность выполнения работы. Соблюдение единого Code Style, аккуратность именования и расположения ассетов.



--------------------------------
План реализации мобильной игры-головоломки Unity
Техническая архитектура
Выбор технологий
Unity 6000.x.x (требование ТЗ)
VContainer - для DI и архитектуры (заменяет синглтоны и менеджеры)
UniTask - для асинхронных операций (загрузка уровней, анимации)
DOTween - для UI анимаций и игровых эффектов
Newtonsoft.Json - для работы с JSON конфигурацией уровней
Структура проекта
Assets/
├── Scripts/
│   ├── Core/
│   │   ├── Architecture/
│   │   ├── Services/
│   │   └── ScriptableObjects/
│   ├── Gameplay/
│   │   ├── Word/
│   │   ├── Cluster/
│   │   └── Validation/
│   ├── UI/
│   │   ├── Screens/
│   │   ├── Components/
│   │   └── Navigation/
│   ├── Data/
│   │   ├── Models/
│   │   └── Persistence/
│   └── Utilities/
├── Resources/
│   └── Levels/
├── Prefabs/
│   ├── UI/
│   └── Gameplay/
└── Scenes/
    ├── Bootstrap.unity
    ├── MainMenu.unity
    ├── Gameplay.unity
    └── Victory.unity


Поэтапный план реализации
Этап 1: Базовая архитектура и DI контейнер
Цель: Создать фундамент архитектуры с VContainer
Что реализуется:
Настройка VContainer и создание основного скоупа
Интерфейсы для всех основных сервисов
Bootstrap сцена для инициализации
Система логирования
Создаваемые файлы:
Scripts/Core/Architecture/
├── IGameService.cs
├── GameLifetimeScope.cs
├── BootstrapInstaller.cs
└── GameLogger.cs

Scripts/Core/Services/
├── ILevelService.cs
├── IProgressService.cs
├── ISceneService.cs
└── IUIService.cs

Тестирование:
Запуск Bootstrap сцены
Проверка резолва зависимостей в логах
Отсутствие ошибок DI
Моки для следующего этапа:
Заглушки сервисов возвращают дефолтные значения

Этап 2: Система навигации и базовые сцены
Цель: Реализовать переходы между сценами
Что реализуется:
SceneService для асинхронной загрузки сцен
Базовые сцены: MainMenu, Gameplay, Victory
Простейший UI с кнопками навигации
Создаваемые файлы:
Scripts/Core/Services/
├── SceneService.cs
└── SceneNames.cs

Scripts/UI/Screens/
├── BaseScreen.cs
├── MainMenuScreen.cs
├── GameplayScreen.cs
└── VictoryScreen.cs

Scripts/UI/Navigation/
└── UINavigationService.cs

Тестирование:
Переходы между всеми сценами работают
Кнопки корректно запускают переходы
Отсутствие зависаний при загрузке
Моки:
Пустые экраны с заглушками кнопок

Этап 3: Модели данных и JSON конфигурация
Цель: Создать структуру данных для уровней
Что реализуется:
Модели данных для уровней, слов, кластеров
JSON схема уровня
Создание 2-3 тестовых уровней в JSON
Сервис загрузки уровней из Resources
Создаваемые файлы:
Scripts/Data/Models/
├── LevelData.cs
├── WordData.cs
├── ClusterData.cs
└── GameSession.cs

Scripts/Core/Services/
└── LevelService.cs

Resources/Levels/
├── level_001.json
├── level_002.json
└── level_003.json

JSON структура уровня:
{
  "levelId": 1,
  "targetWords": [
    { "word": "КЛАСТЕР", "clusters": ["КЛ", "АС", "ТЕР"] },
    { "word": "ПРОЕКТ", "clusters": ["ПРО", "ЕКТ"] },
    { "word": "ЗАДАЧА", "clusters": ["ЗА", "ДА", "ЧА"] },
    { "word": "ИГРОКА", "clusters": ["ИГ", "РО", "КА"] }
  ],
  "availableClusters": ["КЛ", "АС", "ТЕР", "ПРО", "ЕКТ", "ЗА", "ДА", "ЧА", "ИГ", "РО", "КА"]
}

Тестирование:
Успешная загрузка JSON файлов
Корректная десериализация в модели данных
Валидация структуры уровней

Этап 4: Система прогресса и сохранений
Цель: Реализовать сохранение прогресса игрока
Что реализуется:
ProgressService с PlayerPrefs
Сохранение/загрузка пройденных уровней
Логика определения текущего уровня
Создаваемые файлы:
Scripts/Data/Persistence/
├── ProgressService.cs
├── SaveData.cs
└── SaveKeys.cs

Scripts/Data/Models/
└── PlayerProgress.cs

Тестирование:
Сохранение прогресса между запусками
Корректное определение текущего уровня
Сброс прогресса для тестирования
Интеграция с предыдущими этапами:
MainMenu отображает правильный счетчик уровней
Кнопка Play загружает корректный уровень

Этап 5: Основной UI главного меню
Цель: Полностью реализовать главное меню
Что реализуется:
Дизайн и верстка главного меню
Счетчик пройденных уровней
Кнопка Play с логикой загрузки уровня
Базовые анимации UI
Создаваемые файлы:
Scripts/UI/Components/
├── LevelCounter.cs
└── PlayButton.cs

Prefabs/UI/
└── MainMenuCanvas.prefab

Тестирование:
Корректное отображение количества пройденных уровней
Play загружает правильный уровень
UI анимации работают плавно

Этап 6: Базовая структура игрового поля
Цель: Создать визуальную структуру игрового экрана
Что реализуется:
Layout игрового поля с 4 пустыми словами
Горизонтальная прокручиваемая панель для кластеров
Базовая система отображения букв в ячейках
Создаваемые файлы:
Scripts/Gameplay/Word/
├── WordSlot.cs
├── LetterCell.cs
└── GameField.cs

Scripts/Gameplay/Cluster/
├── ClusterView.cs
└── ClusterPanel.cs

Prefabs/UI/
├── GameplayCanvas.prefab
├── WordSlot.prefab
├── LetterCell.prefab
└── ClusterView.prefab

Тестирование:
Отображение 4 пустых слов по 6 ячеек
Прокрутка панели кластеров работает
Корректный layout на разных разрешениях
Моки:
Статичные кластеры без взаимодействия

Этап 7: Система кластеров и их отображение
Цель: Реализовать создание и отображение кластеров
Что реализуется:
Генерация кластеров из данных уровня
Визуальное оформление кластеров с рамками
Адаптивный размер кластеров под количество букв
Создаваемые файлы:
Scripts/Gameplay/Cluster/
├── ClusterFactory.cs
├── ClusterData.cs
└── ClusterManager.cs

Тестирование:
Кластеры генерируются из JSON данных
Корректное отображение 2-4 буквенных кластеров
Рамки кластеров видны и эстетично выглядят

Этап 8: Drag & Drop система
Цель: Реализовать перетаскивание кластеров
Что реализуется:
Система захвата кластеров
Визуальная обратная связь при перетаскивании
Определение зон для размещения
Возврат кластера в исходное положение при неудачном размещении
Создаваемые файлы:
Scripts/Gameplay/Interaction/
├── DragHandler.cs
├── DropZone.cs
├── DragAndDropManager.cs
└── InputHandler.cs

Scripts/Utilities/
└── ScreenUtils.cs

Тестирование:
Кластеры можно захватывать и перетаскивать
Визуальная обратная связь работает
Кластеры возвращаются при неудачном размещении
Интеграция:
Подключение к существующим кластерам
Работа с touch input на мобильных устройствах

Этап 9: Размещение кластеров на игровом поле
Цель: Реализовать логику размещения кластеров в словах
Что реализуется:
Логика размещения кластеров в ячейки слов
Проверка возможности размещения
Автоматическое заполнение ячеек буквами из кластера
Система удаления/перемещения кластеров
Создаваемые файлы:
Scripts/Gameplay/Word/
├── WordSlotManager.cs
├── PlacementValidator.cs
└── LetterCellManager.cs

Scripts/Gameplay/
└── PlacementSystem.cs

Тестирование:
Кластеры размещаются в подходящие позиции
Буквы корректно заполняют ячейки
Нельзя разместить кластер в неподходящую позицию
Кластеры можно убирать и перемещать

Этап 10: Система валидации слов
Цель: Реализовать проверку правильности составленных слов
Что реализуется:
Автоматическая валидация при каждом изменении
Проверка соответствия собранных слов целевым
Визуальная индикация правильных/неправильных слов
Определение условий победы
Создаваемые файлы:
Scripts/Gameplay/Validation/
├── WordValidator.cs
├── GameStateValidator.cs
└── ValidationResult.cs

Scripts/Gameplay/
├── GameManager.cs
└── GameState.cs

Тестирование:
Валидация срабатывает при каждом изменении
Правильно определяются корректные слова
Условие победы срабатывает правильно
Визуальная обратная связь работает

Этап 11: Экран победы
Цель: Реализовать экран завершения уровня
Что реализуется:
Отображение разгаданных слов в порядке решения
Кнопки навигации (Main Menu, Next Level)
Сохранение прогресса при победе
Анимации появления экрана
Создаваемые файлы:
Scripts/UI/Screens/
└── VictoryScreenController.cs

Scripts/UI/Components/
├── CompletedWordsList.cs
└── VictoryButtons.cs

Prefabs/UI/
└── VictoryCanvas.prefab

Тестирование:
Экран появляется при выполнении условий победы
Слова отображаются в правильном порядке
Кнопки работают корректно
Прогресс сохраняется

Этап 12: Полировка и оптимизация
Цель: Финальная оптимизация и улучшение UX
Что реализуется:
Оптимизация производительности (object pooling для UI)
Улучшение анимаций и эффектов
Обработка edge cases
Тестирование на мобильных устройствах
Code review и рефакторинг
Создаваемые файлы:
Scripts/Utilities/
├── ObjectPool.cs
├── PerformanceProfiler.cs
└── MobileInputHelper.cs

Тестирование:
Профилирование производительности
Тестирование на разных разрешениях экрана
Проверка всех edge cases
APK билд и тестирование на устройстве

Критерии готовности для каждого этапа
Чеклист завершения этапа:
[ ] Весь код этапа работает без ошибок
[ ] Написаны XML комментарии для публичных методов
[ ] Следование Code Style проекта
[ ] Нет нарушений принципов SOLID
[ ] Создан git commit с описательным сообщением
[ ] Проведено быстрое тестирование функционала
Обязательные архитектурные решения:
Расширяемость системы загрузки уровней:
ILevelLoader интерфейс для абстракции источника данных
Async/await для загрузки (готовность к сетевым запросам)
Фабричный паттерн для создания различных типов загрузчиков
Расширяемость геймплея:
Конфигурируемые параметры (количество слов, длина слов)
Абстрактные классы для игровых элементов
Event-driven архитектура для связи компонентов
Заменяемость геймплея:
Четкое разделение между Core сервисами и Gameplay логикой
IGameplayController интерфейс для различных типов игр
Независимые UI сервисы от игровой логики
Контроль качества:
Code Style правила:
PascalCase для классов, методов, свойств
camelCase с _ для приватных полей
Префикс On для событий
Группировка using директив
Отсутствие магических чисел
Производительность:
Кэширование компонентов в Awake/Start
Object pooling для часто создаваемых объектов
Минимизация вызовов в Update
Использование StringBuilder для строк
Тестируемость:
Все сервисы реализуют интерфейсы
Минимальная связанность между классами
Внедрение зависимостей через конструктор
Отсутствие прямых ссылок на MonoBehaviour в бизнес-логике

Финальная проверка
Готовность к сдаче проекта:
[ ] Все требования ТЗ выполнены
[ ] APK файл собирается и запускается
[ ] GitHub репозиторий с чистой историей коммитов
[ ] README с описанием архитектуры
[ ] Нет критических багов
[ ] Производительность приемлема на целевых устройствах
Документация:
Архитектурная диаграмма проекта
Описание принятых технических решений
Инструкция по добавлению новых уровней
Описание возможностей расширения
Данный план обеспечивает итеративную разработку с возможностью тестирования на каждом этапе и готовность к расширению функционала в будущем.


